<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE =edge">
    <meta name="viewport" content="width =device-width, initial-scale=1.0">
    <title>Log</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: "Courier New";
            font-size: large;
            overflow-wrap: break-word;
        }

        hr {
            border: 0.1px solid #555555;
        }

        #tb {
            width: 100%;
            background-color: black;
            color: white;
            font-family: "Courier New";
            border: none;
            outline: none;
            font-size: large;
        }

        #spn {
            color: #aaaaaa;
            font-style: italic;
            display: block;
        }
    </style>
</head>
<body>
    <div contenteditable="true" id="tb"></div>
    <hr />
    <span id="spn"></span>
    <br />
    <div id="dv"></div>
    <input style="display:none" type="file" id="fl" />
</body>
<script>
    let notes = [];
    let command = "";
    let editMode = false;
    let textMode = false;
    let startTime = null;
    
    const hiddenTag = "hidden";
    const noteTag = "note";
    const linkTag = "link";
    const taskTag = "task";
    const listTag = "list";
    const expenseTag = "expense";

    window.addEventListener("load", () => {
        loadNotes();
        processData(".task recent:30d");
    });

    document.addEventListener("click", (event) => {
        if (!editMode) {
            document.getElementById("tb").focus();
        }
    });

    document.getElementById("tb").addEventListener("blur", (event) => {
        editDiv(false);
        processData(document.getElementById("tb").innerText);
    });

    document.getElementById("fl").addEventListener("change", () => {
        if (document.getElementById("fl").files.length > 0) {
            importFile();
        }
    });

    processData = (text) => {
        if (!text || /\s$/.test(text)) {
            return;
        }

        if (!text.startsWith(".")) {
            text = `.add ${text}`;
        }

        document.getElementById("tb").innerText = "";
        let all = text.split(" ");
        let action = all[0];
        let content = text.substring(action.length + 1).trim();

        switch (action) {
            case "..": {
                document.getElementById("tb").innerText = command;
                break;
            }
            case ".add": {
                showStatus(action);
                doAdd(content);
                break;
            }
            case ".all": {
                showStatus(action);
                doAll();
                break;
            }
            case ".tag": {
                showStatus(action);
                doTag(content);
                break;
            }
            case ".name": {
                showStatus(action);
                doName(content);
                break;
            }
            case ".note": {
                showStatus(action);
                doNote(content);
                break;
            }
            case ".clear": {
                showStatus(action);
                doClear();
                break;
            }
            case ".reset": {
                showStatus(action);
                doReset();
                break;
            }
            case ".export": {
                showStatus(action);
                doExport(content);
                break;
            }
            case ".print": {
                showStatus(action);
                doPrint(content);
                break;
            }
            case ".import": {
                showStatus(action);
                doImport(content);
                break;
            }
            case ".remove": {
                showStatus(action);
                doRemove(content);
                break;
            }
            case ".cut": {
                showStatus(action);
                doCut(content);
                break;
            }
            case ".copy": {
                showStatus(action);
                doCopy(content);
                break;
            }            
            case ".hide": {
                showStatus(action);
                doHide(content);
                break;
            }            
            case ".move": {
                showStatus(action);
                doMove(content);
                break;
            }
            case ".expense": {
                showStatus(action);
                doExpense(content);
                break;
            }
            case ".list": {
                showStatus(action);
                doList(content);
                break;
            }
            case ".task": {
                showStatus(action);
                doTask(content);
                break;
            }
            case ".link": {
                showStatus(action);
                doLink(content);
                break;
            }            
            case ".text": {
                showStatus(action);
                doText(content);
                break;
            }
            case "timer": {
                doTimer(content);
                break;
            }
            default: {
                showStatus(`${action} - failed`);
            }
        }

        command = text;
    }

    doTimer = (content) => {
        if (!content) {
            if (!!startTime) {
                showMessage(formatMilliSeconds(new Date()-startTime));
                showStatus("stopped", true);
                startTime = null;
            } else {
                startTime = new Date();
                showStatus("started", true);
            }
        }
    }

    doAdd = (text) => {
        if (!text) {
            showStatus("failed", true);
            return;
        }

        let pattern = /#[a-z0-9-]+/g;
        let tags = text.match(pattern);
        let date = extractDate(text);
        if (!(tags || []).some(t => t.length > 0)) {
            tags = [`#${noteTag}`];
            text = `${text} #${noteTag}`;
        }

        notes.push({ date: date, tags: tags, text: text });
        saveNotes();
        let tagList = tags.map(t => t.substring(1)).join("&");
        showNotes(filterData(`.filter recent:1m+tag:${tagList}`));
    }

    doList = (content) => {
        showLists(filterData(`tag:${listTag}+${content}`));
    }

    doTask = (content) => {
        showTasks(filterData(`tag:${taskTag}&!${hiddenTag}+${content}`));
    }

    doNote = (content) => {
        showNotes(filterData(!content ? "recent:1m" : content));
    }

    doAll = () => showNotes(notes);

    doTag = (content) => {
        let tags = [];
        notes.forEach(d => {
            if (!content || d.tags.includes(`#${content}`)) {
                tags = [...tags, ...d.tags];
            }
        });
        tags = [... new Set(tags)].sort();
        showData(tags.join("\n"));
        showStatus(tags.length, true);
    }

    doName = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let names = [];
        let subList = filterData(`tag:${content}`);
        subList.forEach(sl => {
            let matches = sl.text.match(/![a-z0-9-]+/g);
            if (matches) {
                names = [...names, ...matches];
            }
        });
        
        names = [... new Set(names)].sort();
        showData(names.join("\n"));
        showStatus(names.length, true);
    }

    doRemove = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let toRemove = filterData(content);
        notes = notes.filter(d => !toRemove.some(tr => tr.date == d.date && tr.text == d.text));
        saveNotes();
        showNotes(toRemove);
    }

    doHide = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let filtered = filterData(`tag:!${hiddenTag}+${content}`);
        let toHide = notes.filter(n => filtered.some(f => f.date == n.date && f.text == n.text));
        toHide.forEach(th => {
            th.tags.push(`#${hiddenTag}`);
            th.text = `${th.text} #${hiddenTag}`;
        });
        
        saveNotes();
        showNotes(toHide);
    }

    doCut = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let toRemove = filterData(content);
        if (toRemove.length != 1) {
            showStatus("failed", true);
            return;
        }

        notes = notes.filter(d => !toRemove.some(tr => tr.date == d.date && tr.text == d.text));
        saveNotes();
        document.getElementById("tb").innerText = toRemove[0].text;
        showNotes(toRemove);
    }

    doCopy = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let toCopy = filterData(content);
        if (toCopy.length != 1) {
            showStatus("failed", true);
            return;
        }

        document.getElementById("tb").innerText = toCopy[0].text;
        showNotes(toCopy);
    }

    doMove = (content) => {
        if (!content) {
            showStatus("failed", true);
            return;
        }

        let filter = `tag:!${linkTag}&!${expenseTag}&!${taskTag}&!${listTag}+${content}`;
        doExport(filter);
        let toMove = filterData(filter);
        notes = notes.filter(d => !toMove.some(tr => tr.date == d.date && tr.text == d.text));
        saveNotes();
        showNotes(toMove);
    }

    doExpense = (content) => {
        let condition = `tag:${expenseTag}+${ !content ? "recent:1m" : content }`;
        showExpenses(filterData(condition));
    }

    doReset = () => {
        doExport();
        notes = [];
        saveNotes();
        showData("");
        showStatus("done", true);
    }

    doExport = (content) => {
        let toExport = filterData(content);
        saveAsFile(JSON.stringify(toExport), "notes_backup_" + isoToString(new Date()));
        showStatus("done", true);
    }

    doPrint = (content) => {
        let toPrint = filterData(content);
        toPrint.sort((a, b) => new Date(b.date) - new Date(a.date));
        let message = "";
        let currDate;
        toPrint.forEach(l => {
            if (currDate != isoToString(l.date)) {
                message = `${message}[${isoToString(l.date)}]\n\n`;
                currDate = isoToString(l.date);
            }

            message = `${message}${l.text}\n\n`;
        });
        saveAsFile(message, "notes_data_" + isoToString(new Date()));
        showStatus("done", true);
    }

    doImport = (content) => {
        if (content == "reset") {
            notes = [];
        } 
        
        document.getElementById("fl").click();
    }

    doLink = (content) => {
        if (!content) {
           content = "google";
        }

        let all = content.split(" ");
        let site = all[0];
        let param = all.length > 1 ? content.substring(site.length + 1) : "";
        let links = filterData(`tag:${linkTag}&!${hiddenTag}`);
        let link = links.find(n => new RegExp(`(^|\\s+)!${site}($|\\s+)`).test(n.text));
        
        if (!link) {
            showStatus("failed", true);
            return;
        }

        all = link.text.match(/\^\S+/g);
        let url = (all || []).length > 0 ? all[0] : null;
        if (!url) {
            showStatus("failed", true);
            return;
        }

        showData(link.text);
        showStatus("opened", true);
        window.open(url.substring(1).replace("<param>", param));
    }

    doClear = () => { showData(""); showStatus("done", true); }

    doText = (content) => {
        if (!content) {
           showStatus("failed", true);
           return;
        }
        
        switch (content) {
            case "load": {
                textMode = true;
                document.getElementById("fl").click();
                break;
            }
            case "save": {
                saveAsFile(document.getElementById("dv").innerText, "data_" + isoToString(new Date()));
                showStatus("done", true);
                break;
            }
            case "edit": {
                editDiv(true);
                showStatus("done", true);
                break;
            }
            default: {
                showStatus("failed", true);
            }
        }
    }

    editDiv = (status) => {
        editMode = status;
        document.getElementById("dv").contentEditable = status;
    }

    filterData = (content) => {
        let filters = !content ? [] : content.split("+");
        let subData = [...notes];
        filters.forEach(f => {
            if (!f || !f.trim() || f.split(":").length < 2) {
                return;
            }
            
            let field = f.split(":")[0].trim();
            let condition = f.split(":")[1].trim();
            switch (field) {
                case "date": {
                    let range = condition.split("-");
                    let from = new Date(range[0]);
                    let to = new Date(range[0]);
                    if (range.length > 1) {
                        to = new Date(range[1]);
                    }
                    subData = subData.filter(s => new Date(isoToString(s.date)) >= from && new Date(isoToString(s.date)) <= to);
                    break;
                }
                case "tag": {
                    if (condition.indexOf("|") > 0) {
                        let tagFilters = condition.split("|");
                        subData = subData.filter(s => tagFilters.some(tf => s.tags.includes(`#${tf}`)));
                    }
                    else {
                        let tagFilters = condition.split("&");
                        tagFilters.forEach(tf => {
                            if (tf.startsWith("!")) {
                                subData = subData.filter(s => !s.tags.includes(`#${tf.substring(1)}`));
                            } else {
                                subData = subData.filter(s => s.tags.includes(`#${tf}`));
                            }
                        });
                    }
                    break;
                }
                case "name": {
                    if (condition.indexOf("|") > 0) {
                        let nameFilters = condition.split("|");
                        subData = subData.filter(s => nameFilters.some(nf => new RegExp(`(^|\\s+)!${nf}($|\\s+)`).test(s.text)));
                    }
                    else {
                        let nameFilters = condition.split("&");
                        nameFilters.forEach(nf => {
                            subData = subData.filter(s => new RegExp(`(^|\\s+)!${nf}($|\\s+)`).test(s.text));
                        });
                    }
                    break;
                }
                case "text": {
                    let textFilters = condition.split("&");
                    textFilters.forEach(tf => {
                        subData = subData.filter(s => s.text.indexOf(tf) > -1);
                    });
                    break;
                }
                case "recent": {
                    let today = new Date();
                    let to = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    let mode = condition.substring(condition.length - 1);
                    let number = condition.substring(0, condition.length - 1) - 1;
                    let from = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    switch (mode) {
                        case "d": {
                            from.setDate(from.getDate() - number);
                            break;
                        }
                        case "m": {
                            from.setMonth(from.getMonth() - number);
                            from.setDate(1);
                            break;
                        }
                    }
                    subData = subData.filter(s => new Date(isoToString(s.date)) >= from && new Date(isoToString(s.date)) <= to);
                    break;
                }
                case "next": {
                    let today = new Date();
                    today.setDate(today.getDate() + 1);
                    let from = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    let mode = condition.substring(condition.length - 1);
                    let number = condition.substring(0, condition.length - 1) - 1;
                    let to = new Date(from.getFullYear(), from.getMonth(), from.getDate());
                    switch (mode) {
                        case "d": {
                            to.setDate(to.getDate() + number);
                            break;
                        }
                        case "m": {
                            to = new Date(to.getFullYear(), to.getMonth() + 1 + number, 0)
                            break;
                        }
                    }
                    subData = subData.filter(s => new Date(isoToString(s.date)) >= from && new Date(isoToString(s.date)) <= to);
                    break;
                }
            }
        });
        return subData;
    }

    importFile = () => {
        let fileReader = new FileReader();
        fileReader.onload = (event) => {
            if (textMode) {
                document.getElementById("dv").innerText = event.target.result;
                showStatus("done", true);
                textMode = false;
                return;
            }
            let importedData = JSON.parse(event.target.result);
            importedData.forEach(i => notes.push(i));
            saveNotes();
            showStatus(importedData.length, true);
        };
        fileReader.readAsText(document.getElementById("fl").files[0], "UTF-8");
        document.getElementById("fl").value = null;
    }

    showNotes = (list) => {
        list.sort((a, b) => new Date(b.date) - new Date(a.date));
        let message = "";
        let currDate;
        list.forEach(l => {
            if (currDate != isoToString(l.date)) {
                message = `${message}[${isoToString(l.date)}]\n\n`;
                currDate = isoToString(l.date);
            }
            message = `${message}${l.text}\n\n`;
        });
        showData(message);
        showStatus(list.length, true);
    }

    showExpenses = (list) => {
        list.sort((a, b) => new Date(b.date) - new Date(a.date));
        let summaryList = [];
        let minDate = new Date();
        let maxDate = new Date("3/1/24");
        list.forEach(l => {
            let categories = l.text.match(/![a-z0-9-]+/g);
            let category = (categories || []).length >= 1 ? categories[0].substring(1) : expenseTag;
            let values = l.text.match(/£[0-9.-]+/g);
            let value = (values || []).length == 0 || isNaN(parseInt(values[0].substring(1))) ? 0 : parseInt(values[0].substring(1));
            let matchingEntry = summaryList.find(sl => sl.category == category);
            minDate = minDate > new Date(l.date) ? new Date(l.date) : minDate;
            maxDate = maxDate < new Date(l.date) ? new Date(l.date) : maxDate;
            let detail = `${isoToString(l.date)} ${l.text}`;
            if (!matchingEntry) {
                summaryList.push({ category, value, detail });
            } else {
                matchingEntry.value += value;
                matchingEntry.detail = `${matchingEntry.detail}\n${detail}`;
            }
        });
        let total = summaryList.reduce((accumulated, item) => accumulated + item.value, 0);
        summaryList.sort((a, b) => b.value == a.value ? b.category - a.category  : b.value - a.value);
        let message = `[${isoToString(minDate)} - ${isoToString(maxDate)}]\n\nTotal ${total}\n`;
        summaryList.forEach(sl => message = `${message}\n${sl.category} ${sl.value}`);
        message = `${message}\n`;
        summaryList.forEach(sl => message = `${message}\n${sl.category} ${sl.value}\n${sl.detail}`);
        showData(message);
        showStatus(summaryList.length, true);
    }

    showLists = (list) => {
        list.sort((a, b) => new Date(b.date) - new Date(a.date));
        let subList = [];
        list.forEach(l => {
            let names = l.text.match(/![a-z0-9-]+/g);
            let name = (names || []).length > 0 ? names[0].substring(1) : listTag;
            let item = l.text.replace(/![a-z0-9-]+/g, "").replace(/#[a-z0-9-]+/g, "");
            let matchingEntry = subList.find(sl => sl.name == name);
            if (!matchingEntry) {
                subList.push({ name, item: `- ${item}` });
            } else {
                matchingEntry.item = `${matchingEntry.item}\n- ${item}`;
            }
        });
        let message = "";
        subList.forEach(sl => message = `${message}[${sl.name}]\n\n${sl.item}\n\n`);
        showData(message);
        showStatus(list.length, true);
    }

    showTasks = (list) => {
        let subList = [];
        let currDate = new Date();
        let currName = "";
        list.sort((a, b) => new Date(a.date) - new Date(b.date));
        list.forEach(l => {
            let names = l.text.match(/![a-z0-9-]+/g);
            let name = (names || []).length > 0 ? names[0].substring(1) : taskTag;
            let item = l.text.replace(/![a-z0-9-]+/g, "").replace(/#[a-z0-9-]+/g, "").replace(/@\S+/g, "");
            let date = isoToString(l.date);
            let matchingDate = subList.find(sl => sl.date == date);
            if (!matchingDate) {
                subList.push({ date, tasks: [ { name, item } ] });
            } else {
                matchingDate.tasks.push({ name, item });
            }
        });

        subList.forEach(d => {
            d.tasks.sort((a, b) => a.item - b.item);
        });
        let message = "";
        subList.forEach(d => {
            message = `${message}[${d.date}]\n\n`;
            d.tasks.forEach(t => {
                message = `${message}- ${t.item} !${t.name}\n`;
            });
            message = `${message}\n`;
        });
        showData(message);
        showStatus(list.length, true);
    }

    saveAsFile = (data, fileName) => {
        let a = document.createElement("a");
        a.download = fileName;
        a.innerHTML = "export";
        a.href = window.URL.createObjectURL(new Blob([data], { type: "text/plain" }));
        a.style.display = "none";
        a.onclick = function (event) { document.body.removeChild(event.target); };
        document.body.appendChild(a);
        a.click();
    }

    showData = (text) => document.getElementById("dv").innerText = text;

    showStatus = (text, append) => document.getElementById("spn").innerText = `${append ? document.getElementById("spn").innerText + " - " : ""}${text}`;

    saveNotes = () => localStorage.setItem("notes", JSON.stringify(notes));

    loadNotes = () => notes = JSON.parse(localStorage.getItem("notes") || "[]");

    isoToString = (date) => {
        date = new Date(date);
        return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
    }

    formatMilliSeconds = (ms) => {
        return `${Math.floor(ms/(60*60*1000)).toString().padStart(2,"0")}:${Math.floor(ms%(60*60*1000)/60).toString().padStart(2,"0")}:${Math.floor(ms%60).toString().padStart(2,"0")};
    }

    extractDate = (text) => {
        let dates = text.match(/@\S+/g);
        let date = new Date();
        let dateString = (dates || []).some(d => d.length > 0) ? dates[dates.length - 1].substring(1) : "";
        switch (dateString) {
            case "tomorrow": {
                date.setDate(date.getDate() + 1);
                break;
            }
            case "yesterday": {
                date.setDate(date.getDate() - 1);
                break;
            }
            case "weekend": {
                let noOfDays = 6 - date.getDay();
                date.setDate(date.getDate() + (noOfDays > 0 ? noOfDays : 7));
                break;
            }
            case "month": {
                date.setMonth(date.getMonth() + 1);
                date.setDate(1);
                break;
            }
            case "year": {
                date.setFullYear(date.getFullYear() + 1);
                date.setMonth(0);
                date.setDate(1);
                break;
            }
            default: {
                if ((dateString.endsWith("d") || dateString.endsWith("m") || dateString.endsWith("y"))) {
                    let mode = dateString.substring(dateString.length - 1);
                    let number = parseInt(dateString.substring(0, dateString.length - 1));
                    switch (mode) {
                        case "d": {
                            date.setDate(date.getDate() + number);
                            break;
                        }
                        case "m": {
                            date.setMonth(date.getMonth() + number);
                            break;
                        }
                        case "y": {
                            date.setYear(date.getFullYear() + number);
                            break;
                        }
                    }
                }
                else if (dateString.length >= 6
                        && dateString.length <= 10
                        && dateString.indexOf("/") > 0
                        && !isNaN(new Date(dateString).getDate())) {
                    date = new Date(dateString);
                }
            }
        }

        return date;
    }
    
</script>
</html>

<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE =edge">
    <meta name="viewport" content="width =device-width, initial-scale=1.0">
    <title>Log</title>
    <style>
        div {
            line-height: 1.5em;
            overflow-wrap: anywhere;
            outline: none;
        }
    </style>
</head>
<body>
    <div id="dvTitle"></div>
    <hr id="hr" />
    <div id="dvContent"></div>
</body>
<script>
    let tags = [];
    let dates = [];
    let list = [];
    let onFileLoad = null;
    let extension = null;
    let manual = {
    an: (param) => {
// 7.1.0 an(titleText) - title
dvTitle.innerText = param;
    },
    go: () => {
// 7.2.0 go() - edit
if (list.length > 0) {
  extension.ui(list[0].text);
  extension.ui("edit");
}
    },
    up: (param) => {
// 7.3.0 up(text) - write
let a = document.createElement("a");
a.download = "export";
a.href = window.URL.createObjectURL(new Blob([param], { type: "text/plain" }));
a.style.display = "none";
a.onclick = (event) => {
  document.body.removeChild(event.target);
  event.stopPropagation();
};
document.body.appendChild(a);
a.click();
    },
    ex: () => {
// 7.4.0 ex() - read
let file = document.createElement("input");
file.type = "file";
file.style.display = "none";
file.onchange = (event) => {
  let fr = new FileReader();
  fr.onload = (event) => {
    if (onFileLoad != null) {
      onFileLoad(event.target.result);
    }
  };
  fr.readAsText(event.target.files[0], "UTF-8");
  document.body.removeChild(event.target);
};
file.oncancel = (event) => document.body.removeChild(event.target);
file.onclick = (event) => event.stopPropagation();
document.body.appendChild(file);
file.click();
    },
    ui: (param) => {
// 7.5.0 ui(mode:edit|clear|export|import|cancel|text) - content
switch(param)
{
  case "edit": {
    dvContent.contentEditable = true;
    dvContent.onclick = (event) => event.stopPropagation();
    break;
  }
  case "clear": extension.ui(""); break;
  case "export": extension.up(dvContent.innerText); break;
  case "import": {
    onFileLoad = (text) => {
      extension.ui(text);
      onFileLoad = null;
    };
    extension.ex();
  }
  case "cancel": {
    dvContent.contentEditable = false;
    dvContent.onclick = null;
    break;
  }
  default: dvContent.innerText = param;
}
    },
    is: () => {
// 7.6.0 is() - bind
let content = "";
list.forEach(l => {
  let dv = document.createElement("div");
  let diffTags = l.tags.filter(t => !tags.includes(t));
  let lines = l.text.split("\n");
  let text = lines.length > 1 ? `${lines[0]}...` : l.text;
  text = diffTags.length > 0 ? `${text} under ${diffTags.join(", ")}` : text;
  content = `${content} - ${text} on ${l.date.toLocaleDateString("en-us", {day: "numeric", month: "numeric"})}\n`;
});
extension.an(`${tags.length > 0? tags.join(" ") : "all"} (${list.length})`);
extension.ui(content);
    },
    so: () => {
// 7.7.0 so() - load
fetchByTags(tags, (result) => {
  list = result;
  extension.is();
});
    },
    in: (param) => {
// 7.8.0 in(tags) - list
tags = !!param ? param.split(" ").filter(p => !!p) : [];
if (tags.length == 1) {
  fetchByTag(param, (result) => {
    list = result;
    extension.is();
  });
  return;
}

extension.so();
    },
    on: (param) => {
// 7.9.0 on(dates) - get
let dates = !!param ? param.split(" ").filter(p => !!p) : [];
let start = dates.length > 0 ? new Date(dates[0]) : new Date(new Date().toLocaleDateString("en-us"));
let end = dates.length > 1 ? new Date(dates[1]) : start;
fetchByDates(tags, start, end, (result) => {
  list = result;
  extension.is();
});
    },
    as: (param) => {
// 7.10.0 as(text) - add
add([{
  id: new Date().getTime(),
  date: new Date(new Date().toLocaleDateString("en-us")),
  tags,
  text: param
}], () => extension.so());
    },
    to: (param) => {
// 7.11.0 to(mode:date|tag|text) - update
if (list.length == 0) {
  return;
}

let doUpdate = (convert, revert) => {
  let text = prompt("replace", convert(list[0]));
  if (!!text) {
    revert(list[0], text);
    update(list, () => extension.so());
  } else if (text == "") {
    remove([list[0]], () => extension.so());
  }
};

switch (param) {
  case "date": doUpdate((l) => l.date.toLocaleDateString("en-us"), (l, t) => l.date = new Date(t)); break;
  case "tag": doUpdate((l) => l.tags.join(" "), (l, t) => l.tags = t.split(" ")); break;
  default: doUpdate((l) => l.text, (l, t) => l.text = t); break;
}
    },
    be: (param) => {
// 7.12.0 be(mode:date|tag|text) - replace
if (list.length == 0) {
  return;
}

let doUpdate = (convert, revert) => {
  let text = prompt("update", convert(list[0]));
  if (!!text) {
    list.forEach(l => revert(l, text));
    update(list, () => extension.so());
  }
};

switch (param) {
  case "date": doUpdate((l) => l.date.toLocaleDateString("en-us"), (l, t) => l.date = new Date(t)); break;
  case "tag": doUpdate((l) => l.tags.join(" "), (l, t) => l.tags = t.split(" ")); break;
  default: doUpdate((l) => l.text, (l, t) => l.text = t); break;
}
    },
    un: () => {
// 7.13.0 un() - remove
if (list.length > 0 && confirm(`remove - ${list.length}?`)) {
  remove(list, () => extension.so());
}
    },
    my: (param) => {
// 7.14.0 my(mode:data|json) - export
let isJson = param != "data";
let toLine = (l) => {
  let date = `@${l.date.toLocaleDateString("en-us")}`;
  let tag = l.tags.map(t => `#${t}`).join(" ");
  return `${date} ${tag} ${l.text}`;
};
let text = isJson ? JSON.stringify(list) : list.map(l => toLine(l)).join("\n\n");
extension.up(text);
extension.ui(`exported ${list.length}`);
    },
    by: (param) => {
// 7.15.0 by(mode:reset|append) - import
let append = param != "reset";
onFileLoad = (text) => {
  let importedData = JSON.parse(text);
  importedData.slice().reverse().forEach((d, i) => {
    d.id = new Date().getTime() + (i/importedData.length);
    d.date = new Date(d.date);
  });
  let startImport = (removed = 0) => {
    add(importedData, () => {
      onFileLoad = null;
      extension.ui(`removed (${removed})\nimported (${importedData.length})`);
    });
  };
  if (!append) {
    remove(list, () => startImport(list.length));
    return;
  }

  startImport();
};
extension.ex();
    },
    hi: () => {
// 7.16.0 hi() - initialize
extension.in();
    },
    at: (param) => {
// 7.17.0 at(text) - find
list = list.filter(l => l.text.includes(param));
extension.is();
    },
    ok: () => {
// 7.18.0 ok() - save
if (list.length > 0) {
  extension.ui("cancel");
  list[0].text = dvContent.innerText;
  update([list[0]], () => extension.so());
}
    },
    of: () => {
// 7.19.0 of() - tags
fetchTags(tags, (result) => {
  let tagNames = tags.length > 0 ? tags.join(" ") : "all";
  let tagList = result.map(t => t.join(" "));
  extension.ui(`${tagNames} (${tagList.length})\n\n${tagList.join("\n")}`);
});
    },
    do: (param) => {
// 7.20.0 do(expression) - calculate
if (!!param && /^[0-9+\-*/()^.]+$/g.test(param)) {
  let fn = new Function(`return (${param})`);
  extension.ui(`${param}\n\n${fn()}`);
}
    },
    mi: (param) => {
// 7.21.0 mi(date, 0Days, 2Days, blueDays) - milk
let greenPrice = 23.50;
let bluePrice = 21.50;
let normalCount = 4.0;
let sc = 30.0;

let params = param.split(",");
let date = !!param ? new Date(params[0]) : new Date();
let noOfDays = new Date(date.getFullYear(), date.getMonth()+1, 0).getDate();
let noOfNo = params.length > 1 ? parseInt(params[1]) : 0;
let noOfTwo = params.length > 2 ? parseInt(params[2]) : 0;
let noOfBlue = params.length > 3 ? parseInt(params[3]) : 0;

let noOfFour = noOfDays - noOfTwo - noOfNo;
let noOfPackets = (normalCount*noOfFour) + (2*noOfTwo);
let greenTotal = greenPrice*noOfPackets;  
let total = (greenPrice*normalCount*noOfDays) - (greenPrice*noOfTwo*2) - ((greenPrice-bluePrice)*noOfBlue) - (greenPrice*normalCount*noOfNo) + sc;

let summary = "F2 Sriram flats";
summary += "\n" + date.toLocaleString("default", { month: "short", year: "numeric" });
summary = (noOfNo == 0) ? summary : `${summary}\n${noOfNo} X 0 = 0 packets`;
summary = (noOfTwo == 0) ? summary : `${summary}\n${noOfTwo} X 2 = ${noOfTwo*2} packets`;
summary = `${summary}\n${noOfFour} X 4 = ${noOfFour*4} packets`;
summary = `${summary}\n${noOfPackets} X ${greenPrice} = ${greenTotal}`;
summary = (noOfBlue == 0) ? summary :`${summary}\n${noOfBlue} blue packets = -${(greenPrice-bluePrice)*noOfBlue}`;
summary = `${summary}\nSC ${sc}`;
summary = `${summary}\nTotal: ${total}`;

extension.ui(`${param}\n\n${summary}`);
    },
    migrate: () => {
// 7.22.0 migrate() - migrate
list = [];
Object.keys(extension).forEach((key, i) => {
  tags = ["extension", key];
  let fn = extension[key].toString();
  let text = fn.substring(fn.indexOf("//"), fn.lastIndexOf("\n"));
  list.push({
    id: new Date().getTime() + (i/Object.keys(extension).length),
    date: new Date(new Date().toLocaleDateString("en-us")),
    tags,
    text
  });
});
add(list, () => extension.so());
    }
    };

    let dvTitle = document.getElementById("dvTitle");
    let dvContent = document.getElementById("dvContent");
    let hr = document.getElementById("hr");

    window.addEventListener("load", () => {
        initialize(() => initializeExtension(() => extension.hi()));
    });

    window.addEventListener("click", (event) => {
        let text = prompt("command");
        if (!!text && !!text.trim()) {
            executeExtension(text.trim());
        }
    });

    initializeExtension = (callback) => {
        extension = manual; callback(); return;
        extension = { no: new Function("content", "dvContent.innerText = `${content} - not found`") };
        fetchByTags(["extension"], (result) => {
            result.forEach(r => extension[r.tags.at(-1)] = new Function("param", r.text));
            callback();
        });
    }

    executeExtension = (content) => {
        if (!!content && !!content.trim()) {
            let name = content.split(" ")[0];
            let param = content.substring(name.length + 1).trim();
            (extension[name] ?? extension.no)(param);
        }
    }

    const dbName = "log-db";
    const dbVersion = 1;
    const storeName = "log-store"
    const idField = "id";
    const dateField = "date";
    const tagsField = "tags";
    const dateIndex = "date-index";
    const tagsIndex = "tags-index";
    const tagsMultiIndex = "tags-multi-index";
    const minValue = "";
    const maxValue = "\xff";
    const maxCount = 100;

    initialize = (callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onupgradeneeded = (event) => {
            const db = event.target.result;
            const store = db.createObjectStore(storeName, { keyPath: idField });
            store.createIndex(dateIndex, dateField, { unique: false });
            store.createIndex(tagsIndex, tagsField, { unique: false });
            store.createIndex(tagsMultiIndex, tagsField, { unique: false, multiEntry: true });
            store.transaction.oncomplete = (event) => {
                callback();
            };
        };
        dbRequest.onsuccess = (event) => callback();
        dbRequest.onerror = (event) => console.log(event);
    }

    fetchByDates = (tagList, startDate, endDate, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const index = db.transaction(storeName, "readonly").objectStore(storeName).index(dateIndex);
            index.getAll(IDBKeyRange.bound(startDate, endDate)).onsuccess = (event) => {
                let result = event.target.result.filter(r => tagList.every(t => r.tags.includes(t)));
                callback(result);
            };
        };
    }

    fetchByTag = (tag, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const index = db.transaction(storeName, "readonly").objectStore(storeName).index(tagsMultiIndex);
            let result = [];
            index.openCursor(IDBKeyRange.only(tag), 'prev').onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && result.length <= maxCount) {   
                    result.push(cursor.value);
                    cursor.continue();
                } else {
                    callback(result);
                }
            };
        };
    }

    fetchByTags = (tagList, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const index = db.transaction(storeName, "readonly").objectStore(storeName).index(tagsIndex);
            let result = [];
            index.openCursor(IDBKeyRange.bound(tagList, [...tagList, maxValue]), 'prev').onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && result.length <= maxCount) {   
                    result.push(cursor.value);
                    cursor.continue();
                } else {
                    callback(result);
                }
            };
        };
    }

    fetchTags = (tagList, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const index = db.transaction(storeName, "readonly").objectStore(storeName).index(tagsIndex);
            let result = [];
            index.openKeyCursor(IDBKeyRange.bound([...tagList, minValue], [...tagList, maxValue]), "nextunique").onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {   
                    result.push(cursor.key);
                    cursor.continue();
                } else {
                    callback(result);
                }
            };
        };
    }

    add = (items, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(storeName, "readwrite");
            const store = transaction.objectStore(storeName);
            items.forEach(i => store.add(i));
            transaction.oncomplete = (event) => callback();
            transaction.onerror = (event) => {
                callback();
            };
        }
    }

    update = (items, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(storeName, "readwrite");
            const store = transaction.objectStore(storeName);
            items.forEach(i => store.put(i));
            transaction.oncomplete = (event) => callback();
        };
    }

    remove = (items, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(storeName, "readwrite");
            const store = transaction.objectStore(storeName);
            items.forEach(i => store.delete(i.id));
            transaction.oncomplete = (event) => callback();
        };
    }

    fetch = (tagList, callback) => {
        const dbRequest = window.indexedDB.open(dbName, dbVersion);
        dbRequest.onsuccess = (event) => {
            const db = event.target.result;
            const index = db.transaction(storeName, "readonly").objectStore(storeName).index(tagsIndex);
            index.get(tagList).onsuccess = (event) => callback(event.target.result);
        };
    }
</script>
</html>
